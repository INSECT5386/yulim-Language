<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Pyodide Encode/Decode í…ŒìŠ¤íŠ¸</title>
  <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
</head>
<body>
  <h1>Pyodide Encode/Decode í…ŒìŠ¤íŠ¸ ğŸš€</h1>

  <textarea id="inputText" rows="4" cols="50" placeholder="ì—¬ê¸°ì— í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”"></textarea><br>
  <button onclick="runEncode()">ì¸ì½”ë”© ì‹¤í–‰</button>
  <button onclick="runDecode()">ë””ì½”ë”© ì‹¤í–‰</button>

  <p><b>ê²°ê³¼:</b></p>
  <pre id="output"></pre>

  <script>
    let pyodide;

    async function initPyodide() {
      pyodide = await loadPyodide();

      const pythonCode = `

# -------------------- ê¸°ë³¸ ìëª¨ í…Œì´ë¸” --------------------
CHOSUNG = ['ã„±','ã„²','ã„´','ã„·','ã„¸','ã„¹','ã…','ã…‚','ã…ƒ','ã……','ã…†','ã…‡','ã…ˆ','ã…‰','ã…Š','ã…‹','ã…Œ','ã…','ã…']
JUNGSUNG = ['ã…','ã…','ã…‘','ã…’','ã…“','ã…”','ã…•','ã…–','ã…—','ã…˜','ã…™','ã…š','ã…›','ã…œ','ã…','ã…','ã…Ÿ','ã… ','ã…¡','ã…¢','ã…£']
JONGSUNG = ['','ã„±','ã„²','ã„³','ã„´','ã„µ','ã„¶','ã„·','ã„¹','ã„º','ã„»','ã„¼','ã„½','ã„¾','ã„¿','ã…€','ã…','ã…‚','ã…„','ã……','ã…†','ã…‡','ã…ˆ','ã…Š','ã…‹','ã…Œ','ã…','ã…']

# -------------------- ë¶„ë¦¬ í•¨ìˆ˜ --------------------
def split_syllable_char(ch):
    code = ord(ch) - 0xAC00
    if code < 0 or code > 11171:
        return ch, '', ''
    cho = code // (21*28)
    jung = (code % (21*28)) // 28
    jong = code % 28
    return CHOSUNG[cho], JUNGSUNG[jung], JONGSUNG[jong]

# -------------------- ë§¤í•‘ í…Œì´ë¸” --------------------
mapping = {
    'ã„±': 'gos', 'ã„²': 'gosgos', 'ã„´': 'nuk', 'ã„·': 'di', 'ã„¸': 'didi', 'ã„¹': 'ray',
    'ã…': 'mi', 'ã…‚': 'by', 'ã…ƒ': 'byby', 'ã……': 'xi', 'ã…†': 'xixi', 'ã…‡': 'a',
    'ã…ˆ': 'jo', 'ã…‰': 'jojo', 'ã…Š': 'cho', 'ã…‹': 'kay', 'ã…Œ': 'twi', 'ã…': 'choa', 'ã…': 'hwo',
    'ã…': 'i', 'ã…‘': 'ya', 'ã…“': 'au', 'ã…•': 'you', 'ã…—': 'o', 'ã…›': 'yo',
    'ã…œ': 'wo', 'ã… ': 'yu', 'ã…¡': 'ul', 'ã…£': 'il', 'ã…¢': 'ui'
}

jong_mapping = {
    'ã„³': 'gosxi', 'ã„µ': 'nukjo', 'ã„¶': 'nukhwo',
    'ã„º': 'raygos', 'ã„»': 'raymi', 'ã„¼': 'rayby',
    'ã„½': 'rayxi', 'ã„¾': 'raytwi', 'ã„¿': 'raychoa',
    'ã…€': 'rayhwo', 'ã…„': 'byxi'
}

josa_mapping = {
    "ì€": "royo", "ëŠ”": "royo",
    "ì„": "kayo", "ë¥¼": "kayo",
    "ì´": "liyo", "ê°€": "liyo"
}

# -------------------- Encoder --------------------
def encode(text: str) -> str:
    result = []
    for ch in text:
        if ch in josa_mapping:
            result.append(josa_mapping[ch])
            continue
        c, v, f = split_syllable_char(ch)
        parts = []
        if c in mapping:
            parts.append(mapping[c])
        if f:
            if f in mapping:
                parts.append(mapping[f])
            elif f in jong_mapping:
                parts.append(jong_mapping[f])
        if v in mapping:
            parts.append(mapping[v])
        if parts:
            result.append("".join(parts))
        else:
            result.append(ch)
    return " ".join(result)

# -------------------- Decoder ì¤€ë¹„ --------------------
rev_initial = {v: k for k, v in mapping.items() if k in CHOSUNG}
rev_vowel   = {v: k for k, v in mapping.items() if k in JUNGSUNG}
rev_jong_single = {v: k for k, v in mapping.items() if k in JONGSUNG and k != ''}
rev_jong_complex = {v: k for k, v in jong_mapping.items()}
rev_josa = {v: k for k, v in josa_mapping.items()}

# í† í° ì‚¬ì „
all_units = list(rev_initial.keys()) + list(rev_vowel.keys()) + list(rev_jong_single.keys()) \
            + list(rev_jong_complex.keys()) + list(rev_josa.keys())
all_units = sorted(all_units, key=lambda x: -len(x))

def segment_token(token: str):
    res = []
    i = 0
    while i < len(token):
        matched = False
        for u in all_units:
            if token.startswith(u, i):
                res.append(u)
                i += len(u)
                matched = True
                break
        if not matched:
            res.append(token[i])  # ì‹¤íŒ¨ì‹œ ê·¸ëŒ€ë¡œ
            i += 1
    return res

def compose_syllable(cho, jung, jong):
    try:
        cho_idx = CHOSUNG.index(cho)
        jung_idx = JUNGSUNG.index(jung)
        jong_idx = JONGSUNG.index(jong)
    except ValueError:
        return None
    code = 0xAC00 + (cho_idx * 21 + jung_idx) * 28 + jong_idx
    return chr(code)

def decode_segments(segments):
    out = []
    i = 0
    while i < len(segments):
        seg = segments[i]

        # ì¡°ì‚¬
        if seg in rev_josa:
            out.append(rev_josa[seg])
            i += 1
            continue

        # ì´ˆì„± + (ì¢…ì„±?) + ì¤‘ì„±
        if seg in rev_initial:
            cho = rev_initial[seg]
            jong = ''
            jung = ''
            if i+1 < len(segments) and segments[i+1] in rev_vowel:
                jung = rev_vowel[segments[i+1]]
                i += 2
            elif i+2 < len(segments) and segments[i+2] in rev_vowel and segments[i+1] in rev_jong_single:
                jong = rev_jong_single[segments[i+1]]
                jung = rev_vowel[segments[i+2]]
                i += 3
            else:
                i += 1
            if jung != '':
                syll = compose_syllable(cho, jung, jong)
                if syll: out.append(syll)
            else:
                out.append(cho)
            continue

        # ëª¨ìŒ ë‹¨ë…
        if seg in rev_vowel:
            out.append(rev_vowel[seg])
            i += 1
            continue

        out.append(f"[?{seg}]")
        i += 1
    return "".join(out)

def decode(text: str) -> str:
    tokens = text.split()
    out = []
    for t in tokens:
        segs = segment_token(t)
        decoded = decode_segments(segs)
        out.append(decoded)
        
    return "".join(out)

`;
      await pyodide.runPythonAsync(pythonCode);
      console.log("Pyodide ì´ˆê¸°í™” ì™„ë£Œ!");
    }

    async function runEncode() {
      const text = document.getElementById("inputText").value;
      try {
        pyodide.globals.set("js_text", text); // JS â†’ Python ì „ë‹¬
        let result = await pyodide.runPythonAsync("encode(js_text)");
        document.getElementById("output").textContent = result;
      } catch (err) {
        console.error(err);
        document.getElementById("output").textContent = "ì—ëŸ¬ ë°œìƒ: " + err;
      }
    }

    async function runDecode() {
      const text = document.getElementById("inputText").value;
      try {
        pyodide.globals.set("js_text", text); // JS â†’ Python ì „ë‹¬
        let result = await pyodide.runPythonAsync("decode(js_text)");
        document.getElementById("output").textContent = result;
      } catch (err) {
        console.error(err);
        document.getElementById("output").textContent = "ì—ëŸ¬ ë°œìƒ: " + err;
      }
    }

    initPyodide();
  </script>
</body>
</html>
